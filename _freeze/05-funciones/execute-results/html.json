{
  "hash": "c5cde4aba1857d757dd633b5e033d1ff",
  "result": {
    "markdown": "---\ntitle: \"Funciones\"\nsubtitle: \"Curso básico de R\"\nauthor: \"Alfredo Sánchez Alberca &nbsp; [{{< fa envelope >}}](mailto:asalber@ceu.es) [{{< fa brands twitter >}}](https://twitter.com/aprendeconalf) [{{< fa home >}}](https://aprendeconalf.es)\"\ninstitute: Universidad CEU San Pablo\nlogo: img/logos/sticker.png\n# title-slide-attributes:\n#     #data-background-color: black\n#     data-background-image: img/prompt-julia.png\n#     data-background-size: contain\nlang: es\nfig-align: center\nnavigation-mode: vertical\nslide-level: 3\n---\n\n\n## Funciones\n\nUna función es un bloque de código que tiene asociado un nombre, de manera que cada vez que se quiera ejecutar el bloque de código basta con invocar el nombre de la función. \n\nLas funciones permite dividir el código en unidades lógicas que resultan más fáciles de manejar y mantener.\n\nEn R las funciones son objetos en sí mimas y pueden usarse como cualquier otro dato. El tipo de dato de las funciones es `function`.\n\n## Definición y llamada a funciones\n\nPara definir una función se utiliza la siguiente estructura de código:\n\n> _`nombre.funcion`_ `<- function (`_`parámetros`_`) {`  \n&ensp;&ensp;_`<código>`_  \n`}`\n\nEl código que va entre llaves se conoce como _cuerpo de la función_.\n\nPara llamar a la función y que se ejecute el código de su cuerpo hay que utilizar el nombre de la función y a continuación los valores pasados a sus parámetros entre paréntesis.\n\n---\n\n:::{#exm-creacion-funcion}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-1_5a7565aebf1c93dd4edf52318d63d314'}\n\n```{.r .cell-code}\n# Definición de la función\nsaludo <- function() {\n  print(\"¡Hola!\")\n}\nclass(saludo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\n# Llamada a la función\nsaludo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"¡Hola!\"\n```\n:::\n:::\n\n:::\n\n## Parámetros y argumentos de una función\n\nUna función puede recibir valores cuando se invoca a través de unas variables conocidas como _parámetros_ que se definen entre paréntesis en la declaración de la función. En el cuerpo de la función se pueden usar estos parámetros como si fuesen variables.\n\nLos valores que se pasan a la función en una llamada o invocación concreta de ella se conocen como _argumentos_ y se asocian a los parámetros de la declaración de la función.\n\n:::{#exm-funcion-con-parametros}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-2_c2277824a378304cf643f111393f7145'}\n\n```{.r .cell-code}\n# Función con un parámetro\nsaludo <- function(nombre) {\n  print(paste(\"¡Hola \", nombre, \"!\", sep = \"\"))\n}\n# Llamada a la función con un argumento\nsaludo(\"Alf\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"¡Hola Alf!\"\n```\n:::\n:::\n\n:::\n\n### Paso de argumentos a una función\n\nLos argumentos de una función pueden pasarse de dos formas: \n\n- **Argumentos posicionales**: Se asocian a los parámetros de la función en el mismo orden que aparecen en la definición de la función.\n- **Argumentos nominales**: Se indica explícitamente el nombre del parámetro al que se asocia un argumento de la forma `parametro = argumento`. En este caso el orden de los argumentos no importa.\n\n---\n\n:::{#exm-paso-parametros-funcion}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-3_8cba1c8c7fd41a0db50c23cc0f888186'}\n\n```{.r .cell-code}\n# Función con un argumento por defecto\narea.triangulo <- function(base, altura) {\n  base * altura / 2\n}\n# Cálculo del área de un triángulo de base 4 y altura 3\n# Paso de argumentos por posición. \narea.triangulo(4, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n# Paso de argumentos por nombre\narea.triangulo(altura = 3, base = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n:::\n\n### Argumentos por defecto \n\nEn la definición de una función se puede asignar a cada parámetro un argumento por defecto, de manera que si se invoca la función sin proporcionar ningún argumento para ese parámetro, se utiliza el argumento por defecto.\n\n:::{#exm-argumento-defecto-funcion}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-4_13105bb73ddee3fd9c8bbd8991606c8a'}\n\n```{.r .cell-code}\nsaludo <- function(nombre, lenguaje = \"R\") {\n  print(paste(\"¡Hola \", nombre, \"! ¡Bienvenido a \", lenguaje, \"!\", sep = \"\"))\n}\n# Llamada a la función con un argumento\nsaludo(\"Alf\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"¡Hola Alf! ¡Bienvenido a R!\"\n```\n:::\n:::\n\n:::\n\n## Retorno de una función\n\nUna función puede devolver un objeto de cualquier tipo tras su invocación. Para ello se utiliza la función `return()`, indicando entre paréntesis el valor que devuelve la función. \n\nEl retorno suele realizarse al final del cuerpo de la función, porque con él finaliza la ejecución de la función y se devuelve el control de la ejecución al punto desde donde se llamó a la función, de manera que cualquier instrucción de cuerpo que vaya después no se ejecutará. \n\nSi no se indica ningún objeto, la función devolverá el valor de la última expresión calculada en el cuerpo de la función. \n\n---\n\n:::{#exm-retorno-funciones}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-5_3d038ea3830abe1bf75476d4edb90917'}\n\n```{.r .cell-code}\n# Función que devuelve el area de un triángulo\narea.triangulo <- function(base, altura) {\n  return(base * altura / 2)\n}\narea.triangulo(4, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n# Función que devuelve el valor absoluto de un número\nvalor.absoluto <- function(x) {\n  if (x < 0)\n    return(x * -1)\n  else\n    return(x)\n}\nvalor.absoluto(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nvalor.absoluto(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n:::\n\n---\n\nPara devolver más de un valor se pueden utilizar estructuras de datos como vectores, listas, matrices o data frames.\n\n:::{#exm-retorno-funcion-lista}\nA continuación se muestra un ejemplo de una función de devuelve una lista.\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-6_ff3814ec9b37759a8538e0ae4f02e774'}\n\n```{.r .cell-code}\ncirculo <- function(radio) {\n  return(list(perimetro = 2 * pi * radio, area = pi * radio ^ 2))\n}\ncirculo(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$perimetro\n[1] 31.41593\n\n$area\n[1] 78.53982\n```\n:::\n\n```{.r .cell-code}\ncirculo(5)$perimetro\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 31.41593\n```\n:::\n\n```{.r .cell-code}\ncirculo(5)$area\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 78.53982\n```\n:::\n:::\n\n:::\n\n## Entorno y ámbito de las variables\n\nEl entorno de un programa en R es el conjunto de todos los objetos (funciones, variables, etc.) creados durante la ejecución del programa. Cuando se ejecuta el interprete de R siempre se crea un primer entorno `R_GlobalEnv` conocido como entorno global. Es posible referirse a él en cualquier momento con la constante `.GlobalEnv`.\n\nPara ver el entorno activo en cada momento de la ejecución y el contenido del mismo se utiliza la siguiente función:\n\n- `environment()`: Devuelve el nombre del entorno actual. \n- `ls()`: Devuelve un vector con los nombres de las objetos (variables, funciones, etc.) que contiene el entorno global.\n\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-7_73199dd6ee8912602bb60ae86d3874ac'}\n\n:::\n\n\n---\n\n:::{#exm-acceso-entorno-global}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-8_3e000ff886dd010f570118c2746f1c05'}\n\n```{.r .cell-code}\nx <- 4\ny <- 3\narea.triangulo <- function(base, altura) {\n  base * altura / 2\n}\nenvironment()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: R_GlobalEnv>\n```\n:::\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"area.triangulo\" \"x\"              \"y\"             \n```\n:::\n:::\n\n:::\n\nComo se puede observar en el ejemplo anterior, los parámetros de la función `base` y `altura` no aparecen en el entorno global. En R, cuando se ejecuta una función se crea un nuevo entorno hijo dentro del entorno al que pertenece la función. Durante la ejecución de la función este pasa a ser el entorno activo y cuando termina la ejecución de la función deja de serlo y vuelve a activarse el entorno padre desde donde se llamó a la función.\n\n---\n\n:::{#exm-activacion-entorno-funcion}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-9_17cc6f5f94c50f76fbf397d73fa1ad6e'}\n\n```{.r .cell-code}\nx <- 4\ny <- 3\narea.triangulo <- function(base, altura) {\n  print(\"Entorno de la función area.triangulo\") \n  print(environment())\n  print(ls())\n  return(base * altura / 2)\n}\nprint(\"Entorno fuera de la función\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Entorno fuera de la función\"\n```\n:::\n\n```{.r .cell-code}\nenvironment()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: R_GlobalEnv>\n```\n:::\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"area.triangulo\" \"x\"              \"y\"             \n```\n:::\n\n```{.r .cell-code}\narea.triangulo(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Entorno de la función area.triangulo\"\n<environment: 0x562487747890>\n[1] \"altura\" \"base\"  \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n:::\n\n---\n\nLos parámetros y los objetos (funciones, variables, etc.) definidos dentro de una función son de _ámbito local_, mientras que los objetos definidos fuera de ella en alguno de los entornos ancestros son de _ámbito global_.\n\nTanto los parámetros como las variables del ámbito local de una función sólo están accesibles durante la ejecución de la función, es decir, cuando termina la ejecución de la función estas variables desaparecen y no son accesibles desde fuera de la función.\n\nCuando una función declara un objeto (función, variable, etc.) que ya existe en alguno de los entornos ancestros con ámbito global, durante la ejecución de la función el objeto global queda eclipsado por el local y no es accesible hasta que finaliza la ejecución de la función.\n\n:::{#exm-eclise-variables-globales-por-locales}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-10_e61049953b74ae48e2092e9cb482b9cc'}\n\n```{.r .cell-code}\nlenguaje = \"Python\"\nsaludo <- function(lenguaje) {\n  print(paste(\"Bienvenido a\", lenguaje))  \n}\nsaludo(\"R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Bienvenido a R\"\n```\n:::\n:::\n\n:::\n\n---\n\nLas variables globales están accesibles siempre que no sean eclipsadas por otras con el mismo nombre de ámbito local. Si embargo, cuando se intenta asignar un valor a una variable global en el ámbito local, se crea una nueva variable local. Para asignar valores a variables globales en el ámbito local se tiene que utilizar el operador de superasignación `<<-`.\n\n\n:::{#exm-superasignacion}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-11_3cd84eb70733b7ea10931b8de4c189a6'}\n\n```{.r .cell-code}\nsaludo <- function() {\n  lenguaje <<- \"R\"\n  return(paste(\"Bienvenido a\", lenguaje))\n}\nlenguaje\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Python\"\n```\n:::\n:::\n\n:::\n\n## Componentes de una función\n\nLos tres componentes de una función son:\n\n- **Cuerpo**: Es el código dentro de la función.\n- **Parámetros**: Es la lista de parámetros que requiere la función.\n- **Entorno**: Es donde se ubican las variables de la función.\n\nPara acceder a estos componentes se pueden utilizar las siguientes funciones:\n\n- `body(f)`: Devuelve el cuerpo de la función `f`.\n- `formals(f)`: Devuelve la lista de parámetros de la función `f`.\n- `environment(f)`: Devuelve el entorno de la función `f`.\n\n---\n\n:::{#exm-componentes-funcion}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-12_48011a98d3b36750bd6f4f14a2ec1ac3'}\n\n```{.r .cell-code}\n# Definición de la función\narea.triangulo <- function(base, altura) {\n  base * altura / 2\n}\nbody(area.triangulo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    base * altura/2\n}\n```\n:::\n\n```{.r .cell-code}\nformals(area.triangulo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$base\n\n\n$altura\n```\n:::\n\n```{.r .cell-code}\nenvironment(saludo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: R_GlobalEnv>\n```\n:::\n:::\n\n:::\n\n## Funciones recursivas\n\nUna función recursiva es una función que en su cuerpo contiene una llama a sí misma.\n\nLa recursión es una práctica común en la mayoría de los lenguajes de programación ya que permite resolver las tareas recursivas de manera más natural.\n\nPara garantizar el final de una función recursiva, las sucesivas llamadas tienen que reducir el grado de complejidad del problema, hasta que este pueda resolverse directamente sin necesidad de volver a llamar a la función. De lo contrario la recursión no tendría fin y nunca terminaría la ejecución de la función.\n\n:::{#exm-funcion-recursiva}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-13_265375b50ae9598e0a640b491538322d'}\n\n```{.r .cell-code}\nfactorial <- function(n) {\n  if (n <= 1) return(n)\n  else return(n * factorial(n - 1))\n}\nfactorial(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24\n```\n:::\n:::\n\n:::\n\n## Paquetes\n\nPara facilitar la reutilización código y datos R permite la creación de paquetes que pueden importarse desde otros programas. Un paquete es una colección de código, funciones y datos que se almacenan en un fichero dentro de un directorio llamado `library` en el entorno de R. \n\nPara ver la ubicación de este directorio dentro del sistema de archivos local se puede utilizar la función `.libPaths()`.\n\n:::{#exm-ubiacion-biblioteca-paquetes}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-14_d2338b3f2ca62b5c70d1922f6af059f8'}\n\n```{.r .cell-code}\n.libPaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/home/alf/R/x86_64-pc-linux-gnu-library/4.3\"\n[2] \"/usr/lib/R/library\"                         \n```\n:::\n:::\n\n:::\n\n---\n\nDurante la instalación de R también se instalan varios paquetes básicos que están disponibles en cualquier sesión de trabajo con R. Pero añadir nuevas funciones o procedimientos es necesario instalar el paquete que los contiene y después cargarlo en la sesión de trabajo. \n\nPara ver los paquetes instalados en un ordenador se utiliza la función `library()`.\n\n### Instalación de paquetes\n\nLa mayor parte de los paquetes para R están disponibles en el repositorio oficial [CRAN](Comprehensive R Archive Network) (Comprehensive R Archive Network), aunque cualquier persona puede desarrollar un paquete y ponerlo a disposición de la comunidad en cualquier otro repositorio. \n\nExisten distintas formas de instalar un paquete en R: \n\n- Directamente desde el repositorio oficial CRAN\n- Desde otros repositorios no oficiales (por ejemplo Github)\n- Descargando el paquete e instalándolo manualmente. \n\n---\n\n#### Instalación de paquetes desde el repositorio CRAN\n\nPara instalar un paquete desde el repositorio oficial CRAN se utiliza la siguiente función: \n\n- `install.packages(x)`: Obtiene el paquete con el nombre `x` desde un servidor con el repositorio CRAN y lo instala localmente en el directorio `library` del entorno de R. Se puede instalar más de un paquete a la vez pasando un vector con los nombres de los paquetes.\n\n:::{#exm-instalacion-paquetes}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-15_51ccc014978612becc00e00ebd09740e'}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")\n```\n:::\n\n:::\n\n---\n\n#### Instalación desde otros repositorios (GitHub, GitLab, etc.)\n\nEl paquete `remotes` incorpora funciones para instalar paquetes alojados en otros repositorios habituales para el desarrollo de software como [GitHub](https://github.com/), [GitLab](httpsb://gitlab.com/), etc.\n\n:::{#exm-instalacion-paquetes-github}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-16_a05233c4a2a085bdc17133903ff3c9f8'}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")\nremotes::install_github(\"rkward-community/rk.Teaching\")\n```\n:::\n\n:::\n\n---\n\n#### Instalación desde Bioconductor\n\n[Bioconductor](https://bioconductor.org/) es un repositorio de paquetes especializados en Bioinformática. \n\nBioconductor utiliza sus propio gestor de paquetes `BiocManager`, pero la instalación de paquetes es igualmente sencilla.\n\n:::{#exm-instalacion-paquetes-bioconductor}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-17_fdaac343d0e860f16f782347b90de7d7'}\n\n```{.r .cell-code}\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"edgeR\")\n```\n:::\n\n:::\n\n---\n\n#### Instalación manual\n\nFinalmente es posible instalar un paquete manualmente a partir de su código fuente. Para ello hay previamente hay que descargar el código fuente del paquete en un fichero comprimido en formato zip y después utilizar la siguiente función:\n\n- `install.packages(x, repos = NULL, type = \"source\")`: Instala el paquete ubicado en la ruta `x` del sistema de archivos local en la librería `library`.\n\nUna vez instalado un paquete ya está disponible para cargarlo en cualquier sesión de trabajo de R y no es necesario volver a instalarlo.\n\n### Carga de un paquete\n\nUna vez instalado un paquete, para poder ejecutar su contenido es necesario cargarlo en el entorno de trabajo de R. Para ello se utiliza la siguiente función:\n\n- `library(x)`: Ejecuta el código del paquete `x` en la sesión de trabajo activa.\n\n:::{#exm-carga-paquetes}\n\n::: {.cell hash='05-funciones_cache/revealjs/unnamed-chunk-18_6237c2b52ede4d31236f77ada5cde9ee'}\n\n```{.r .cell-code}\nlibrary(\"remotes\")\n```\n:::\n\n:::\n\n### Paquetes habituales\n\nA continuación se presenta una lista ordenada alfabéticamente (no por importancia) de los paquetes más populares para el análisis de datos:\n\n- [`caret`](https://topepo.github.io/caret/index.html) es un paquete para la creación de modelos de clasificación y regresión mediante aprendizaje automático.\n- [`data.table`](https://www.rdocumentation.org/packages/data.table/) es un paquete para la manipulación de grandes conjuntos de datos (de hasta 100GB) de manera rápida y eficiente. \n- [`devtools`](https://www.rdocumentation.org/packages/devtools/) es un paquete con herramientas para el desarrollo de paquetes en R.\n- [`knitr`](https://www.r-project.org/nosvn/pandoc/knitr.html) es un paquete que proporciona un motor para la generación de informes dinámicos que permite la integración de código en R con los lenguajes de procesamiento de textos LaTeX, HTML, Markdown, AsciiDoc o reStructuredText.\n- [`mlr3`](https://mlr3.mlr-org.com/) es un paquete que proporciona funciones para las principales técnicas de aprendizaje automático.\n- [`plotly`](https://plotly.com/r/) es un paquete para la creación de gráficos interactivos.\n\n---\n\n- [`rmarkdown`](https://rmarkdown.rstudio.com/) es un paquete que facilita el uso del paquete `knitr` para la elaboración de documentos en múltiples formatos (HTML, pdf, Word y otros) permitiendo la integración de código R en el lenguaje Markdown.\n- [`shiny`](https://shiny.rstudio.com/) es un paquete para la construcción de aplicaciones web interactivas.\n- [`tidymodels`](https://www.tidymodels.org/) es una colección de paquetes para la construcción y evalucación de modelos con técnicas de aprendizaje automático.\n- [`tidyverse`](https://www.tidyverse.org/) es una colección de paquetes para la Ciencia de Datos que incluye paquetes para la carga, limpieza, manipulación y representación gráfica de datos.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}