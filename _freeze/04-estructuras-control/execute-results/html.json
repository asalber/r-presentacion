{
  "hash": "4e598f7f1b1697bc0e5043c9188cf137",
  "result": {
    "markdown": "---\ntitle: \"Estructuras de control\"\nsubtitle: \"Curso básico de R\"\nauthor: \"Alfredo Sánchez Alberca &nbsp; [{{< fa envelope >}}](mailto:asalber@ceu.es) [{{< fa brands twitter >}}](https://twitter.com/aprendeconalf) [{{< fa home >}}](https://aprendeconalf.es)\"\ninstitute: Universidad CEU San Pablo\nlogo: img/logos/sticker.png\n# title-slide-attributes:\n#     #data-background-color: black\n#     data-background-image: img/prompt-julia.png\n#     data-background-size: contain\nlang: es\nfig-align: center\nnavigation-mode: vertical\nslide-level: 3\n---\n\n\n## Estructuras de control\n\nComo en otros lenguajes de programación, en R existen instrucciones para controlar el flujo de ejecución de un programa. Básicamente existen dos tipos: \n\n- Condicionales: Son instrucciones que bifurcan el flujo del programa en función de si se cumple o no una condición.\n- Bucles: Son instrucciones que repiten un bloque de código un numero determinado de veces o hasta que se cumple una condición. \n\n## Estructuras condicionales\n\nLas estructuras condicionales permiten evaluar el estado del programa y tomar decisiones sobre qué código ejecutar en función del mismo.\n\n### Condicionales (`if`)\n\nLa principal estructura condicional comienza con la palabra reservada `if`, lleva asociada expresión de tipo lógico o booleano y permite ejecutar un bloque de código dependiendo de si la evaluación de esa expresión es `TRUE` o `FALSE`.\n\n> `if (`_`<exp>`_`) {`  \n&ensp;&ensp;_`<código>`_  \n`}`\n\nSi el resultado de evaluar la expresión `<exp>` es `TRUE` entonces se ejecuta el código `<código>`, mientras que si es `FALSE` no.\n\n---\n\n![Diagrama de flujo de la estructura condicional simple](img/04-estructuras-control/condicional-simple.png)\n\n---\n\n:::{#exm-condicional-simple}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-1_a2cca4a13d03b1b5345e6ecfadc489b4'}\n\n```{.r .cell-code}\nx <- 1\ny <- 0\nif (y != 0){\n  print(x / y)\n}\n```\n:::\n\n:::\n\n---\n\nSi se desea ejecutar un bloque de código alternativo cuando no se cumpla la condición se puede añadir a continuación con la palabra reservada `else`.\n\n> `if (`_`<exp>`_`) {`  \n&ensp;&ensp;_`<código 1>`_  \n`} else {`  \n&ensp;&ensp;_`<código 2>`_  \n`}`\n\nEn este caso, si la evaluación de la condición es `TRUE` se ejecuta el código `<código 1>` y si es `FALSE` se ejecuta el código `<código 2>`.\n\n---\n\n![Diagrama de flujo de la estructura condicional doble](img/04-estructuras-control/condicional-doble.png)\n\n---\n\n:::{#exm-condicional-doble}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-2_ee6a4be9ffd084721df11a87bddc4bec'}\n\n```{.r .cell-code}\nnota <- 8.5\nif (nota < 5){\n  print(\"Suspenso\")\n} else {\n  print(\"Aprobado\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Aprobado\"\n```\n:::\n:::\n\n:::\n\n---\n\nSe puede comprobar más de una condición encadenando otra instrucción `if` tras las instrucción `else`. \n\n> `if (`_`<exp 1>`_`) {`  \n&ensp;&ensp;_`<código 1>`_  \n`} else if (`_`<exp 2>`_`) {`  \n&ensp;&ensp;_`<código 2>`_`) {`  \n...  \n`} else {`  \n&ensp;&ensp;_`<código n>`_  \n`}`\n\nCuando se encadenan múltiples condiciones de esta forma, solamente se ejecuta el bloque de código asociado a la primera condición cuya evaluación sea `TRUE`. El último bloque de código solamente se ejecuta si todas las condiciones son falsas.\n\n---\n\n![Diagrama de flujo de la estructura condicional múltiple](img/04-estructuras-control/condicional-multiple.png)\n\n---\n\n:::{#exm-condicional-multiple}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-3_76442b5b3b76370f7eb03b3af39fa03f'}\n\n```{.r .cell-code}\nnota <- 8.5\nif (nota < 5){\n  print(\"Suspenso\")\n} else if (nota < 7) {\n  print(\"Aprobado\")\n} else if (nota < 9) {\n  print(\"Notable\")\n} else {\n  print(\"Sobresaliente\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Notable\"\n```\n:::\n:::\n\n:::\n\n### La función `switch()`\n\nOtra forma de tomar decisiones sobre el código a ejecutar es la función `switch`. \n\n- `switch(x, l)`: Ejecuta el código del valor de la lista `l` cuyo nombre asociado coincide con el resultado de evaluar la expresión `x`. Si el resultado de evaluar `x` no es ningún nombre de los elementos de la lista devuelve `NULL`.\n\n:::{#exm-condicional-switch}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-4_e16db406f9cde48ec9b1f2993d8d2a3a'}\n\n```{.r .cell-code}\ntipo.iva <- \"reducido\"\nprecio <- 1000\niva <- precio * switch(\n    tipo.iva, \"superreducido\" = 4, \"reducido\" = 10, \"normal\" = 21) / 100\niva\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n:::\n\n:::\n\n## Bucles\n\nUn bucle es una estructura que permite la repetición de un bloque de código. En R existen dos tipos de bucles, los _bucles iterativos_ y los _bucles condicionales_.\n\n### Bucles iterativos (`for`)\n\nLo bucles iterativos repiten un bloque de código un número determinado de veces. Comienzan por la palabra reservada `for` y llevan asociado un _iterador_, que es una variable que recorre una secuencia de un tipo de datos compuesto, normalmente un vector o una lista. El bloque de código se ejecuta tantas veces como elementos tenga la secuencia, y en cada repetición el iterador toma como valor un elemento distinto de la secuencia.\n\n> `for (`_`i`_ ` in ` _`<secuencia>`_`) {`  \n&ensp;&ensp;_`<código>`_  \n`}`\n\n---\n\n![Diagrama de flujo de un bucle iterativo](img/04-estructuras-control/bucle-for.png)\n\n---\n\n:::{#exm-bucle-iterarivo}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-5_979804a970557683a43e71467728fb46'}\n\n```{.r .cell-code}\nasignaturas <- c(\"Matemáticas\", \"Física\", \"Programación\")\nfor (i in asignaturas) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Matemáticas\"\n[1] \"Física\"\n[1] \"Programación\"\n```\n:::\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  print(paste(\"El cuadrado de \", i, \" es \", i^2))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"El cuadrado de  1  es  1\"\n[1] \"El cuadrado de  2  es  4\"\n[1] \"El cuadrado de  3  es  9\"\n[1] \"El cuadrado de  4  es  16\"\n[1] \"El cuadrado de  5  es  25\"\n```\n:::\n:::\n\n:::\n\n---\n\nTambién es posible recorrer los elementos de la secuencia por posición ayudándonos de la siguiente función:\n\n- `seq_along(x)`: que devuelve un vector con los enteros desde 1 hasta el número de elementos de la secuencia `x`.\n\n:::{#exm-bucle-iterativo-posicion}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-6_a04de3471f64ecd7527cf5bedfe48bf5'}\n\n```{.r .cell-code}\nasignaturas <- c(\"Matemáticas\", \"Física\", \"Programación\")\nfor (i in seq_along(asignaturas)){\n  print(paste(\"Asignatura \", i, \":\", asignaturas[i]))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Asignatura  1 : Matemáticas\"\n[1] \"Asignatura  2 : Física\"\n[1] \"Asignatura  3 : Programación\"\n```\n:::\n:::\n\n:::\n\n---\n\nLos bucles iterativos se utilizan habitualmente para recorrer estructuras de una dimensión como los vectores y las listas, donde se sabe de antemano el número de elementos que contiene y, por tanto, el número de iteraciones del bucle. No obstante, también se pueden recorrer estructuras de más de una dimensión, como por ejemplo matrices, utilizando varios bucles `for` anidados.\n\n:::{#exm-bucles-anidados}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-7_c317f6db8c890c525293cb9724534a48'}\n\n```{.r .cell-code}\nx <- matrix(1:6, 2, 3)\nfor (i in 1:nrow(x)) {\n  for (j in 1:ncol(x)){\n    print(x[i,j])\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 3\n[1] 5\n[1] 2\n[1] 4\n[1] 6\n```\n:::\n:::\n\n:::\n\n### Bucles condicionales (`while`)\n\nLos bucles condicionales repiten un bloque de código mientras se cumpla una condición. Comienzan con la palabra reservada `while` y llevan asociada una expresión lógica, de manera que mientras la evaluación de la expresión lógica sea `TRUE` se repite la ejecución del bloque de código que contiene.\n\n> `while (`_`<condición>`_`) {`  \n&ensp;&ensp;_`<código>`_  \n`}`\n\nLa expresión lógica `<condición>` se evalúa antes de ejecutar el bloque de código y solo se ejecuta el `<código>` si el resultado de la evaluación es `TRUE`.\n\n---\n\n![Diagrama de flujo de un bucle condicional](img/04-estructuras-control/bucle-while.png)\n\n---\n\n:::{#exm-bucle-condicional}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-8_c3bd9a042d661fcb5f893b9972555431'}\n\n```{.r .cell-code}\ni <- 5\nwhile (i >= 0) {\n  print(i)\n  i <- i - 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n[1] 4\n[1] 3\n[1] 2\n[1] 1\n[1] 0\n```\n:::\n:::\n\n:::\n\n### La instrucción `break`\n\nLa instrucción `break` se utiliza para detener un bucle y salir de él, tanto en bucles iterativos como en bucles condicionales. Normalmente se suele utilizar esta instrucción cuando se cumple una determinada condición en bloque de código del bucle y se decide parar su ejecución y salir del bucle.\n\n:::{#exm-salida-bucle-break}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-9_936cdae91ca5d9787796557cd839f118'}\n\n```{.r .cell-code}\n# Bucle que recorre los números enteros del -2 al 2 pero termina al llegar al 0.\nfor (i in -2:2) {\n  if (i == 0) {\n    break\n  } \n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2\n[1] -1\n```\n:::\n:::\n\n:::\n\n### La instrucción `next`\n\nLa instrucción `next` se utiliza para interrumpir la ejecución del bloque de código de un bucle, pero en lugar de salir del bucle pasa a la siguiente iteración. Si se trata de un bucle iterativo el iterador pasa al siguiente elemento de la secuencia de iteración y si se trata de un bucle condicional se pasa evaluar de nuevo la condición de repetición. \n\n:::{#exm-continuacion-bucle-next}\n\n::: {.cell hash='04-estructuras-control_cache/revealjs/unnamed-chunk-10_24fbe0b8692436efe255b7ddf0a22d1c'}\n\n```{.r .cell-code}\n# Bucle que recorre los enteros del 1 al 10 pero solo imprime los números pares.\nfor (i in 1:10) {\n  if (i %% 2) {\n    next\n  }\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}