{
  "hash": "2cd4c5b7c8cd0c4b2dca7aebb330f8f1",
  "result": {
    "markdown": "---\ntitle: \"Tipos de datos estructurados\"\nsubtitle: \"Curso básico de R\"\nauthor: \"Alfredo Sánchez Alberca &nbsp; [{{< fa envelope >}}](mailto:asalber@ceu.es) [{{< fa brands twitter >}}](https://twitter.com/aprendeconalf) [{{< fa home >}}](https://aprendeconalf.es)\"\ninstitute: Universidad CEU San Pablo\nlogo: img/logos/sticker.png\n# title-slide-attributes:\n#     #data-background-color: black\n#     data-background-image: img/prompt-julia.png\n#     data-background-size: contain\nlang: es\nfig-align: center\nnavigation-mode: vertical\nslide-level: 3\n---\n\n\n## Tipos de datos estructurados \n\n| Dimensiones | Homogéneos | Heterogéneos |\n|:-:|:-:|:-:|\n| 1 | Vector | Lista |\n| 2 | Matriz | Data frame |\n| n | Array | |\n\n- `str(x)`: Devuelve una cadena de texto con la estructura de `x` en un formato amigable para las personas.\n\n## Vectores\n\nUn _vector_ es una colección ordenada de elementos del mismo tipo. \n\n### Creación de vectores\n\nPara construir un vector se utiliza la función de combinación `c()`:\n\n- `c(x1, x2, ...)`: Devuelve el vector formado por los elementos `x1`, `x2`, etc.\n\nTambién es posible utilizar el operador `:` para generar un vector de números enteros consecutivos:\n\n- `x:y`: Devuelve el vector de números enteros consecutivos desde `x` hasta `y`.\n\n---\n\n:::{#exm-construccion-vectores}\nA continuación se muestran varios ejemplos de construcción de vectores.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-1_b3bda07daec9055d6b2d3437d966bb2a'}\n\n```{.r .cell-code}\nc(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nc(\"uno\", \"dos\", \"tres\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"uno\"  \"dos\"  \"tres\"\n```\n:::\n\n```{.r .cell-code}\n# Vector vacío\nc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\n# Vector con elementos perdidos\nc(1, NA, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 NA  3\n```\n:::\n\n```{.r .cell-code}\n# Vector de números enteros consecutivos del 2 al 6\n2:6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5 6\n```\n:::\n:::\n\n:::\n\n### Vectores con nombres\n\nEs posible asignar un nombre a cada elemento de un vector. Los nombres son etiquetas de texto que se asocian a cada elemento. \n\nPara asociar un nombre a un elemento se utiliza la sintaxis `nombre = valor`, donde `nombre` es una cadena de caracteres y `valor` es el elemento del vector.\n\nPara acceder a los nombres de un vector se utiliza la siguiente función:\n\n- `names(x)`: Devuelve un vector de cadenas de caracteres con los nombres de los elementos del vector `x`.\n\n:::{#exm-acceso-nombres-vector}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-2_45cca9269ebd6f921af8c246be603886'}\n\n```{.r .cell-code}\nnotas <- c(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\nnotas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatemáticas      Física    Economía \n        8.2         6.5         4.5 \n```\n:::\n\n```{.r .cell-code}\nnames(notas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Matemáticas\" \"Física\"      \"Economía\"   \n```\n:::\n:::\n\n:::\n\n### Tamaño de un vector\n\nEl número de elementos de un vector es su _tamaño_ y puede averiguarse con la siguiente función.\n\n- `lenght(x)`: Devuelve el número de elementos del vector `x`.\n\n:::{#exm-tamaño-vector}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-3_95e1536241a14cfd368286c11c1e2695'}\n\n```{.r .cell-code}\nlength(c(1, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nlength(c())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n:::\n\n### Coerción de elementos\n\nLa función `c()` convierte sus argumentos a un mismo tipo de dato, lo que se conoce como _coerción_ de tipos. \n\nLa coerción se produce de los tipos menos flexibles a los más flexibles: \n\n<center>\n`logical` < `integer` < `double` < `character`.\n</center>\n\n:::{#exm-coercion}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-4_7af3edb53432f699865b8aa7f7c90550'}\n\n```{.r .cell-code}\nc(1, 2.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 2.5\n```\n:::\n\n```{.r .cell-code}\nc(FALSE, TRUE, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 2\n```\n:::\n\n```{.r .cell-code}\nc(FALSE, TRUE, 2, \"tres\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"FALSE\" \"TRUE\"  \"2\"     \"tres\" \n```\n:::\n:::\n\n:::\n\n### Acceso a los elementos de un vector\n\nPara acceder a los elementos de un vector se utilizan corchetes `[ ]` a continuación del vector. Dentro de los corchetes se indican los índices de los elementos a los que se quiere acceder, que pueden ser\n\n- Enteros\n- Booleanos\n- Cadenas\n\n---\n\n#### Acceso mediante un índice entero\n\n- `v[i]`: Devuelve el elemento del vector `v` que ocupa la posición `i`.\n- `v[c(i,j,...)]`: Devuelve los elementos del vector `v` que ocupan las posiciones `i`, `j`, etc.\n\n:::{.callout-warning}\nEn R los índices enteros para acceder a los elementos de un vector comienzan en 1.\n:::\n\n---\n\n:::{#exm-acceso-vector}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-5_2b26b15361a02b9f8f689d78a632077c'}\n\n```{.r .cell-code}\nx <- c(2,4,6,8,10)\n# Acceso al elemento que está en la tercera posición\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n# Acceso a los elementos de las posiciones 2 y 4\nx[c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 8\n```\n:::\n\n```{.r .cell-code}\n# Acceso a los elementos de la posición 2 a la 4\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 6 8\n```\n:::\n\n```{.r .cell-code}\n# Acceso a todos los elementos excepto el primero y el cuarto\nx[c(-1, -4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  6 10\n```\n:::\n:::\n\n:::\n\n---\n\n#### Acceso mediante un índice lógico\n\nCuando se utiliza un índice lógico, se obtienen los elementos correspondientes a las posiciones donde está el valor booleano `TRUE`.\n\n:::{#exm-acceso-vector-indice-logico}\n\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-6_54745251a9fd4b8103fd3e238e374a21'}\n\n```{.r .cell-code}\nx <- c(2,4,6,8,10)\n# Acceso a los elementos de las posiciones 2 y 4\nx[c(F,T,F,T,F)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 8\n```\n:::\n:::\n\n:::\n\n---\n\nSe utiliza para seleccionar los elementos que un vector que cumplen una condición (filtros).\n\n:::{#exm-filtros}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-7_72aa61a268e5f55a9c49dd004eca8a65'}\n\n```{.r .cell-code}\nx <- 1:6\nx %% 2 == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n# Filtrado de los valores pares\nx[x %% 2 == 0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6\n```\n:::\n\n```{.r .cell-code}\n# Filtrado de los valores pares menores que 5\nx[x %% 2 == 0 & x < 5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n:::\n\n:::\n\n---\n\n#### Acceso mediante un índice de cadena\n\nSi los elementos de un vector tienen nombre, es posible acceder a ellos usando sus nombres como índices.\n\n:::{#exm-acceso-vector-nombres}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-8_0b59a86d29d0d6b930717657f037d189'}\n\n```{.r .cell-code}\nnotas <- c(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\nnotas[\"Física\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFísica \n   6.5 \n```\n:::\n\n```{.r .cell-code}\nnotas[c(\"Matemáticas\", \"Economía\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatemáticas    Economía \n        8.2         4.5 \n```\n:::\n:::\n\n:::\n\n### Pertenencia a un vector\n\n- `x %in% y`: Devuelve el booleano `TRUE` si `x` es un elemento del vector `y`, y `FALSE` en caso contrario.\n\n:::{#exm-pertenencia-vector}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-9_b0a3911adbb3f9fbdb4267a98428f8b2'}\n\n```{.r .cell-code}\nx <- 1:3\n2 %in% x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n4 %in% x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n\n### Modificación de los elementos de un vector\n\n- `v[i] <- x`: Asigna el dato `x` a la posición `i` del vector `v`.\n- `v[c(i,j,...)] <- x`: Asigna el dato `x` a las posiciones `i`, `j`, etc. del vector `v`.\n\n:::{#exm-modificacion-vectores}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-10_b590464012fe856cc5ce4b18eb8ee19a'}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\nx[2] <- 0\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 3\n```\n:::\n\n```{.r .cell-code}\nx[c(1, 3)] <- 1\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 1\n```\n:::\n:::\n\n:::\n\n### Añadir elementos a un vector \n\n- `c(x, y)`: Devuelve el vector que resulta de añadir al vector `x` los elementos del vector `y`.\n- `append(x, y, pos)`: Devuelve el vector que resulta de añadir al vector `x` los elementos del vector `y`, a continuación de la posición `pos`. El parámetro `pos` es opcional y si no se indica, los elementos de `y` se añaden al final de los de `x`.\n\n:::{#exm-añadir-elementos-vector}\nA continuación se muestran varios ejemplos de añadir nuevos elementos a un vector.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-11_edc35591865d217c698f7756c69d0ef7'}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\nc(x, c(4, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nappend(x, c(4, 5), 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 4 5 3\n```\n:::\n:::\n\n:::\n\n### Eliminar elementos de un vector\n\nPara eliminar los elementos que ocupan una determinada posición se utiliza el operador de acceso, es decir, los corchetes `[ ]` pero con los índices correspondientes a las posiciones a eliminar, en negativo.\n\n:::{#exm-eliminar-elementos-vector}\nA continuación se muestran varios ejemplos de eliminar elementos de un vector.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-12_4d6e02ca4d332d42ecc927e061269994'}\n\n```{.r .cell-code}\nx <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nx[-3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"d\" \"e\"\n```\n:::\n\n```{.r .cell-code}\nx[-c(2,4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"c\" \"e\"\n```\n:::\n:::\n\n:::\n\n### Eliminación de un vector \n\nPara eliminar los elementos de un vector basta con asignar `NULL` a la variable que lo contiene, pero si se quiere liberar la memoria que ocupa la variable se utiliza la función `rm()`.\n\n## Operaciones aritméticas con vectores\n\n### Operaciones aritméticas elemento a elemento\n\nPara vectores numéricos las operaciones aritméticas habituales se aplican elemento a elemento. Si los vectores tienen distinto tamaño, el tamaño del vector más pequeño se equipara al tamaño del mayor, reutilizando sus elementos, empezando por el primero.\n\n:::{#exm-operaciones-aritmeticas-vectores} \n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-13_6403ebc781fd7cf539c9c8c077c16100'}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(0, 1, -1)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 2\n```\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0  2 -3\n```\n:::\n\n```{.r .cell-code}\nx / y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf   2  -3\n```\n:::\n\n```{.r .cell-code}\nx ^ y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0000000 2.0000000 0.3333333\n```\n:::\n:::\n\n:::\n\n---\n\n### Producto escalar de vectores\n\nPara calcular el producto escalar de dos vectores numéricos se utiliza el operador `%*%`. Si los vectores tienen distinto tamaño se produce un error.\n\n:::{#exm-producto-escalar}\nA continuación se muestra un ejemplo del producto escalar de dos vectores.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-14_efdf3beda0068589d009b84a046f2ebe'}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(0, 1, -1)\nx %*% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]   -1\n```\n:::\n:::\n\n:::\n\n## Factores\n\nUn factor es una estructura de datos especial que se utiliza para representar categorías de variables cualitativas y por tanto puede tomar un conjunto finito de valores predefinidos conocido como _niveles_ del factor.\n\n- `factor(x, levels = niveles)`: Crea un dato de tipo factor con los elementos del vector `x`. Los niveles del factor pueden indicarse mediante el parámetro `levels`, pasándole un vector con los valores posibles. Si no se indica el parámetro `levels` los niveles del factor se obtienen automáticamente a partir de los elementos del vector `x` (tantos niveles con valores distintos tenga).\n\nLos factores son en realidad vectores de números enteros a los que se le añade un atributo especial para indicar los niveles del factor.\n\n---\n\n:::{#exm-creacion-factores}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-15_a09f10a464cd80fd547661d242737b6d'}\n\n```{.r .cell-code}\nsexo <- factor(c(\"mujer\", \"hombre\", \"mujer\"))\nsexo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] mujer  hombre mujer \nLevels: hombre mujer\n```\n:::\n\n```{.r .cell-code}\nclass(sexo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nstr(sexo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Factor w/ 2 levels \"hombre\",\"mujer\": 2 1 2\n```\n:::\n\n```{.r .cell-code}\ngrupo.sanguineo <- factor(c(\"B\", \"A\", \"A\"), levels = c(\"A\", \"B\", \"AB\", \"0\"), )\ngrupo.sanguineo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] B A A\nLevels: A B AB 0\n```\n:::\n:::\n\n:::\n\n---\n\nEs posible establecer un orden entre los niveles de un factor añadiendo el parámetro `ordered = TRUE` a la función anterior. Esto es útil para representar categorías ordinales entre las que existe un orden natural.\n\n:::{#exm-creacion-factor-ordenado}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-16_2de6d581915c2a41715de4bbc23ee3c5'}\n\n```{.r .cell-code}\nnivel_estudio <- factor(c(\"Secundarios\", \"Graduado\", \"Bachiller\"),\n    levels = c(\"Sin estudios\", \"Primarios\", \"Secundarios\", \"Bachiller\", \"Graduado\"), \n    ordered = TRUE)\nnivel_estudio\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Secundarios Graduado    Bachiller  \nLevels: Sin estudios < Primarios < Secundarios < Bachiller < Graduado\n```\n:::\n:::\n\n:::\n\nPara comprobar si una estructura es del tipo factor se utiliza la siguiente función:\n\n- `is.factor(x)`: Devuelve el booleano `TRUE` si `x` es del tipo factor, y `FALSE` en caso contrario.\n\n### Acceso a los elementos de un factor\n\nSe puede acceder a los elementos de un factor de la misma manera que se accede a los elementos de un vector. Y para obtener sus niveles se utiliza la siguiente función:\n\n- `levels(x)`: Devuelve un vector con los niveles del factor `x`.\n\n:::{#exm-niveles-factor}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-17_66d9c004ddc5ef1fd7278bb87e245c0c'}\n\n```{.r .cell-code}\nsexo <- factor(c(\"mujer\", \"hombre\", \"mujer\"))\nsexo[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] hombre\nLevels: hombre mujer\n```\n:::\n\n```{.r .cell-code}\nsexo[c(1, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] mujer  hombre\nLevels: hombre mujer\n```\n:::\n\n```{.r .cell-code}\nsexo[-2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] mujer mujer\nLevels: hombre mujer\n```\n:::\n\n```{.r .cell-code}\nlevels(sexo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hombre\" \"mujer\" \n```\n:::\n:::\n\n:::\n\n### Modificación de los elementos de un factor\n\nSe puede modificar los elementos de un factor de manera similar a como se modifican los elementos de un vector. Si el nuevo valor que se quiere asignar no está entre los niveles del factor, se obtiene el valor `NA`.\n\n:::{#exm-modificacion-factor}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-18_538d53445ebc497170b98aa233428ac2'}\n\n```{.r .cell-code}\ngrupo.sanguineo <- factor(c(\"B\", \"A\", \"A\"), levels = c(\"A\", \"B\", \"AB\", \"0\"))\ngrupo.sanguineo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] B A A\nLevels: A B AB 0\n```\n:::\n\n```{.r .cell-code}\ngrupo.sanguineo[2] <- \"AB\"\ngrupo.sanguineo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] B  AB A \nLevels: A B AB 0\n```\n:::\n\n```{.r .cell-code}\ngrupo.sanguineo[1] <- \"C\"\ngrupo.sanguineo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] <NA> AB   A   \nLevels: A B AB 0\n```\n:::\n:::\n\n:::\n\n## Listas\n\nLas listas son colecciones ordenadas de elementos que pueden ser de distintos tipos. Los elementos de una lista también pueden ser de tipos estructurados (vectores o listas), lo que las convierte en el tipo de dato más versátil de R.\n\n### Creación de listas{.scrollable}\n\n- `list(x1, x2, ...)`: Devuelve la lista con los elementos `x1`, `x2`, etc.\n\n:::{#exm-creacion-listas}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-19_99b53d37ba04c3126c44c339e3b50a0a'}\n\n```{.r .cell-code}\nlist(1, \"dos\", TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"dos\"\n\n[[3]]\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Lista con vectores y listas\nx <- list(1, c(\"dos\", \"tres\"), list(4, \"cinco\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"dos\"  \"tres\"\n\n[[3]]\n[[3]][[1]]\n[1] 4\n\n[[3]][[2]]\n[1] \"cinco\"\n```\n:::\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ : num 1\n $ : chr [1:2] \"dos\" \"tres\"\n $ :List of 2\n  ..$ : num 4\n  ..$ : chr \"cinco\"\n```\n:::\n\n```{.r .cell-code}\n# Lista vacía\nlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlist()\n```\n:::\n:::\n\n:::\n\n### Listas con nombres\n\nAl igual que con los vectores, es posible asignar un nombre a cada uno de los elementos de una lista.\n\n:::{#exm-creacion-listas-nombres}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-20_0bd3da32d83898c0b5af89d83d488afd'}\n\n```{.r .cell-code}\nlist(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$dirección\n$dirección$calle\n[1] \"Delicias\"\n\n$dirección$número\n[1] 24\n\n$dirección$municipio\n[1] \"Madrid\"\n```\n:::\n:::\n\n:::\n\n---\n\nPara obtener los nombres de una lista se utiliza la siguiente función:\n\n- `names(x)`: Devuelve un vector de cadenas de caracteres con los nombres de los elementos de la lista `x`.\n\n:::{#exm-acceso-listas}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-21_9be81bea35502f6a190c3b9199d057ac'}\n\n```{.r .cell-code}\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nnames(persona)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"nombre\"    \"edad\"      \"dirección\"\n```\n:::\n:::\n\n:::\n\n### Tamaño de una lista\n\nEl número de elementos de una lista es su _tamaño_ y puede averiguarse con la siguiente función:\n\n- `lenght(x)`: Devuelve el número de elementos de la lista `x`.\n\n:::{#exm-tamaño-lista}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-22_466f5a46734dbba5686a76448ba4b785'}\n\n```{.r .cell-code}\nlength(list(1, \"dos\", TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nlength(list(1, c(\"dos\", \"tres\"), list(4, \"cinco\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nlength(list())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n:::\n\n### Acceso a los elementos de una lista\n\nSe accede a los elementos de una lista de forma similar a los vectores, mediante índices enteros, lógicos o de cadena, entre corchetes `[ ]`.\n\n---\n\n#### Acceso mediante un índice entero\n\n:::{#exm-acceso-lista-indice-entero}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-23_9bdf1c334f574d71c6879693f9818783'}\n\n```{.r .cell-code}\nx <- list(1, \"dos\", TRUE, 4.5)\n# Acceso al elemento que está en la segunda posición\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"dos\"\n```\n:::\n\n```{.r .cell-code}\n# Acceso a los elementos de las posiciones 1 y 3\nx[c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Acceso a todos los elementos excepto el primero y el cuarto\nx[c(-1, -4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"dos\"\n\n[[2]]\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n---\n\n#### Acceso mediante un índice lógico\n\nCuando se utiliza un índice lógico, se obtienen los elementos correspondientes a las posiciones donde está el valor booleano `TRUE`.\n\n:::{#exm-acceso-listas-logico}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-24_27714c0caf7745f1a37d29ce3aa23fa6'}\n\n```{.r .cell-code}\nx <- list(1, \"dos\", TRUE, 4.5)\nx[c(T,F,F,T)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4.5\n```\n:::\n\n```{.r .cell-code}\nx < 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE    NA  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# Filtrado de valores menores que 2\nx[x < 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\nNULL\n\n[[3]]\n[1] TRUE\n```\n:::\n:::\n\nObsérvese que para los elementos que no tiene sentido la comparación se obtiene `NA`, y que el acceso mediante este índice devuelve `NULL`.\n:::\n\n---\n\n#### Acceso mediante nombres\n\nSi los elementos de una lista tienen nombre, se puede acceder a ellos utilizando sus nombres como índices. La única diferencia con el acceso mediante cadenas de vectores es que se obtiene siempre una lista, incluso cuando sólo se quiere acceder a un elemento. Para obtener un elemento, y no una lista con ese único elemento, se utilizan dobles corchetes `[[ ]]`.\n\n---\n\n:::{#exm-acceso-listas-nombres}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-25_4f7600f32ddd8be23591f9badc686e51'}\n\n```{.r .cell-code}\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\npersona[c(\"edad\", \"nombre\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$edad\n[1] 21\n\n$nombre\n[1] \"María\"\n```\n:::\n\n```{.r .cell-code}\npersona[\"nombre\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nombre\n[1] \"María\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(persona[\"nombre\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\n# Acceso a un único elemento\npersona[[\"nombre\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"María\"\n```\n:::\n\n```{.r .cell-code}\n# Acceso a una lista anidada\npersona[[\"dirección\"]][[\"municipio\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Madrid\"\n```\n:::\n:::\n\n:::\n\n---\n\nUna alternativa a los dobles corchetes es el operador de acceso a listas `$`. Este operador además permite utilizar coincidencias parciales en los nombres de los elementos para acceder a ellos.\n\n:::{#exm-acceso-listas-nombres-$}\nA continuación se muestran varios ejemplos de acceso a los elementos de una lista mediante el operador `$`.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-26_1a29a395735966666d1606fb06d5f2a1'}\n\n```{.r .cell-code}\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n# Acceso a un único elemento\npersona$nombre\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"María\"\n```\n:::\n\n```{.r .cell-code}\n# Acceso mediante coincidencia parcial\npersona$nom\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"María\"\n```\n:::\n\n```{.r .cell-code}\n# Acceso a una lista anidada\npersona$dirección$municipio\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Madrid\"\n```\n:::\n:::\n\n:::\n\n### Modificación de los elementos de una lista\n\nPara modificar uno o varios elementos de una lista basta con acceder a esos elementos y reasignarles valores con el operador de asignación.\n\n:::{#exm-modificacion-listas}\nA continuación se muestran varios ejemplos de modificación de los elementos de una lista.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-27_46a53350d83a93a6229bb2cfd499121c'}\n\n```{.r .cell-code}\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$edad <- 22\npersona\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nombre\n[1] \"María\"\n\n$edad\n[1] 22\n```\n:::\n:::\n\n:::\n\n### Añadir elementos a una lista \n\nLa forma más sencilla de añadir un elemento con nombre a una lista es indicando el nombre con el operador `$` y asignándole un valor con el operador de asignación `<-`:\n\n- `x$nombre <- y`: Añade el elemento `y` a la lista `x` con el nombre `nombre`. \n\nEl nuevo elemento se añade siempre al final de la lista.\n\nPara añadir elementos sin nombre o en una posición determinada se puede utilizar la función `append()`:\n\n- `append(x, y, pos)`: Devuelve la lista vector que resulta de añadir a `x` los elementos de la lista `y`, a continuación de la posición `pos`. El parámetro `pos` es opcional y si no se indica, los elementos de `y` se añaden al final de los de `x`.\n\n---\n\n:::{#exm-añadir-elementos-listas}\nA continuación se muestran varios ejemplos de añadir nuevos elementos a una lista.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-28_0f39e50891f9920a5fe49cb1ef21f324'}\n\n```{.r .cell-code}\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$email <- \"maria@ceu.es\"\npersona\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$email\n[1] \"maria@ceu.es\"\n```\n:::\n\n```{.r .cell-code}\nappend(persona, list(\"sexo\" = \"Mujer\"), 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$sexo\n[1] \"Mujer\"\n\n$email\n[1] \"maria@ceu.es\"\n```\n:::\n:::\n\n:::\n\n### Conversión de una lista en un vector\n\nEs posible convertir una lista en un vector con la siguiente función:\n\n- `unlist(x)`: Devuelve el vector que resulta de aplanar recursivamente la lista `x` y convertir todos los elementos al mismo tipo mediante coerción de tipos.\n\n:::{#exm-aplanar-lista}\nA continuación se muestran varios ejemplos de conversión de una lista en un vector.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-29_08f803b88b567b30650e005e50becefc'}\n\n```{.r .cell-code}\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nunlist(persona)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             nombre                edad     dirección.calle    dirección.número \n            \"María\"                \"21\"          \"Delicias\"                \"24\" \ndirección.municipio \n           \"Madrid\" \n```\n:::\n\n```{.r .cell-code}\ntypeof(unlist(persona))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n:::\n\n:::{.callout-warning}\nObsérvese que cuando se convierte una lista en un vector, los elementos de la lista se convierten al tipo más general mediante coerción.\n:::\n\n## Matrices\n\nUna matriz es una estructura de datos bidimensional de elementos del mismo tipo organizados en filas y columnas. \n\nUna matriz es similar a un vector pero contiene una atributo adicional con sus dimensiones (número de filas y número de columnas).\n\n### Creación de matrices\n\n- `matrix(x, nrow = m, ncol = n)`: Devuelve la matriz con los elementos del vector `x` organizados en `n` filas y `m` columnas. Habitualmente basta con especificar el número de filas o el número de columnas.\n\n:::{#exm-creacion-matrices}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-30_c18996325098fc0401c61beca5ae1452'}\n\n```{.r .cell-code}\nmatrix(1:6, nrow = 2, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\nmatrix(1:6, nrow = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\nmatrix(1:6, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\n# La matriz de 1 x 1 \nmatrix()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]   NA\n```\n:::\n:::\n\n:::\n\n---\n\nComo se puede observar en el ejemplo anterior, los elementos se disponen por columnas, pero se pueden disponer los elementos por filas pasando el parámetro `byrow = TRUE` a la función `matrix`.\n\n:::{#exm-creacion-matrices-por-filas}\nA continuación se muestran varios ejemplos de creación de matrices.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-31_37ad966751cf1cd82fe0a5379c024365'}\n\n```{.r .cell-code}\nmatrix(1:6, nrow = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\nmatrix(1:6, nrow = 2, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n:::\n:::\n\n:::\n\n### Matrices con nombres de filas y columnas\n\nEs posible poner nombres a las filas y a las columnas de una matriz añadiendo el parámetro `dimnames` y pasándole una lista de dos vectores de cadenas con los nombres de las filas y las columnas respectivamente.\n\n:::{#exm-creacion-matrices-con-nombres}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-32_2f91d3746e8e03de7e30e3cf35102051'}\n\n```{.r .cell-code}\nmatrix(1:6, nrow = 2, ncol = 3, \n    dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      columna1 columna2 columna3\nfila1        1        3        5\nfila2        2        4        6\n```\n:::\n:::\n\n:::\n\n---\n\nPara obtener los nombres de las filas y las columnas de una matriz se utilizan las siguientes funciones:\n\n- `rownames(x)`: Devuelve un vector de cadenas de caracteres con los nombres de las filas de la matriz `x`.\n- `colnames(x)`: Devuelve un vector de cadenas de caracteres con los nombres de las columnas de la matriz `x`.\n\n:::{#exm-obtencion-nombres-matriz}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-33_744ff7580fd648cc9a96700024459970'}\n\n```{.r .cell-code}\nx <- matrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\nrownames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"fila1\" \"fila2\"\n```\n:::\n\n```{.r .cell-code}\ncolnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"columna1\" \"columna2\" \"columna3\"\n```\n:::\n:::\n\n:::\n\n### Tamaño y dimensiones de una matriz\n\n- `length(x)`: Devuelve un entero con el número de elementos de la matriz `x`.\n- `nrow(x)`: Devuelve un entero con el número de filas de la matriz `x`.\n- `ncol(x)`: Devuelve un entero con el número de columnas de la matriz `x`.\n- `dim(x)`: Devuelve un vector de dos enteros con el número de filas y el número de columnas de la matriz `x`.\n\n:::{#exm-dimensiones-matriz}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-34_788d2ee72d6c7065ecbdbd44d5425cd0'}\n\n```{.r .cell-code}\nx <- matrix(1:6, nrow = 2)\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nnrow(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nncol(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ndim(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n:::\n\n:::\n\n---\n\nUsando esta última función se pueden modificar las dimensiones de una matriz asignando un vector de dos enteros con las nuevas dimensiones. Esto también permite crear una matriz a partir de un vector.\n\n:::{#exm-modificacion-dimensiones-matriz}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-35_111ddffa86b1e0c39fbd41c733d6273d'}\n\n```{.r .cell-code}\nx <- 1:6\ndim(x) <- c(2, 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\ndim(x) <- c(3, 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n:::\n\n:::\n\n### Acceso a los elementos de una matriz\n\nPara acceder a los elementos de una matriz se utilizan dos índices (uno para las filas y otro para las columnas), separados por comas y entre corchetes `[]` a continuación de la matriz. Al igual que para los vectores, los índices pueden \n\n- Enteros \n- Booleanos\n- Cadenas\n\n---\n\n#### Acceso mediante índices enteros\n\n- `x[i,j]`: Devuelve el elemento de la matriz `x` que está en la fila `i` y la columna `j`.\n\nSe puede acceder a más de un elemento indicando un vector de enteros para las filas y otro para las columnas. De esta manera se obtiene una submatriz. Si no se indica la fila o la columna se obtienen todos los elementos de todas las filas o columnas. \n\n---\n\n:::{#exm-acceso-matriz}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-36_1db34b4ea98dcb556f36717e3bdcaba3'}\n\n```{.r .cell-code}\nx <- matrix(1:9, nrow = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\n# Acceso al elemento de la segunda fila y tercera columna\nx[2,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(1, 3), c(3, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    7    4\n[2,]    9    6\n```\n:::\n\n```{.r .cell-code}\n# Acceso a la primera fila\nx[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 7\n```\n:::\n\n```{.r .cell-code}\n# Acceso a la segunda columna\nx[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 5 6\n```\n:::\n:::\n\n:::\n\n---\n\n### Acceso mediante índices lógicos\n\nCuando se utilizan índices lógicos, se obtienen los elementos correspondientes a las filas y columnas donde está el valor booleano `TRUE`.\n\n:::{#exm-acceso-matriz-logico}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-37_77f71278c2b643eabf48905f88f595e4'}\n\n```{.r .cell-code}\nx <- matrix(1:9, nrow = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\n# Acceso al elemento de la segunda fila y tercera columna\nx[c(F, T, F), c(F, F, T)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n# Acceso a la submatriz de la primera y tercera filas, y segunda y tercera columnas\nx[c(T, F, T), c(F, T, T)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    4    7\n[2,]    6    9\n```\n:::\n\n```{.r .cell-code}\n# Acceso a la primera fila\nx[c(T, F, F), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 7\n```\n:::\n\n```{.r .cell-code}\n# Acceso a la segunda columna\nx[, c(F, T, F)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 5 6\n```\n:::\n:::\n\n:::\n\n---\n\n#### Acceso mediante índices de cadena\n\nSi las filas y las columnas de una matriz tienen nombre, es posible acceder a sus elementos usando los nombres de las filas y columnas como índices.\n\n:::{#exm-acceso-matriz-nombres}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-38_b25fa1031352757c12e2b4635734256e'}\n\n```{.r .cell-code}\nx <- matrix(1:9, nrow = 3, dimnames = list(c(\"f1\", \"f2\", \"f3\"), c(\"c1\", \"c2\", \"c3\")))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   c1 c2 c3\nf1  1  4  7\nf2  2  5  8\nf3  3  6  9\n```\n:::\n\n```{.r .cell-code}\n# Acceso al elemento de la segunda fila y tercera columna\nx[\"f2\", \"c3\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(\"f1\", \"f3\"), c(\"c3\", \"c2\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   c3 c2\nf1  7  4\nf3  9  6\n```\n:::\n:::\n\n:::\n\n---\n\nFinalmente, es posible combinar distintos tipos de índices (enteros, lógicos o de cadena) para indicar las filas y las columnas a las que acceder.\n\n### Pertenencia a una matriz\n\nPara comprobar si un valor en particular es un elemento de una matriz se puede utilizar el operador `%in%`:\n\n- `x %in% y`: Devuelve el booleano `TRUE` si `x` es un elemento de la matriz `y`, y `FALSE` en caso contrario.\n\n:::{#exm-pertenencia-matriz}\nA continuación se muestran varios ejemplos de pertenencia de elementos a una matriz.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-39_31780246051319a31a87a7e30a385bc4'}\n\n```{.r .cell-code}\nx <- matrix(1:9, nrow = 3)\n2 %in% x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n-1 %in% x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n\n### Modificación de los elementos de una matriz\n\nPara modificar uno o varios elementos de una matriz basta con acceder a esos elementos y usar el operador de asignación para asignar nuevos valores.\n\n:::{#exm-modificacion-matriz}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-40_523682e5119b2f6ea0d5a1f1f138faed'}\n\n```{.r .cell-code}\nx <- matrix(1:9, nrow = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\nx[2,3] <- 0\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    0\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\nx[c(1, 3), 1:2] <- -1\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   -1   -1    7\n[2,]    2    5    0\n[3,]   -1   -1    9\n```\n:::\n:::\n\n:::\n\n### Añadir elementos a una matriz\n\nPara añadir nuevas filas o columnas a una matriz se utilizan las siguientes funciones:\n\n- `rbind(x, y)`: Devuelve la matriz que resulta de añadir nuevas filas a la matriz `x` con los elementos del vector `y`.\n- `cbind(x, y)`: Devuelve la matriz que resulta de añadir nuevas columnas a la matriz `x` con los elementos del vector `y`.\n\n---\n\n:::{#exm-añadir-filas-columnas-matriz}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-41_b49fb8d805f67b853b29cb6e0b4cd5a5'}\n\n```{.r .cell-code}\nx <- matrix(1:6, nrow = 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\n# Añadir una nueva fila\nrbind(x, c(7, 8, 9))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n[3,]    7    8    9\n```\n:::\n\n```{.r .cell-code}\n# Añadir una nueva columna\ncbind(x, c(7, 8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n:::\n\n:::\n\n:::{.callout-warning}\nObsérvese que si el número de elementos proporcionados en el vector es menor del necesario para completar la fila o columna, se reutilizan los elementos del vector empezando desde el principio.\n:::\n\n### Trasponer una matriz\n\nPara trasponer una matriz se utiliza la función siguiente:\n\n- `t(x)`: Devuelve la matriz traspuesta de la matriz `x`.\n\n:::{#exm-trasposicion-matriz}\nA continuación se muestran un ejemplo de la trasposición de una matriz.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-42_c52b47b5790d2262a3b9fcea2b9ac0c4'}\n\n```{.r .cell-code}\nx <- matrix(1:6, nrow=2)\nt(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n```\n:::\n:::\n\n:::\n\n### Operaciones aritméticas con matrices{.scrollable}\n\nPara matrices numéricas las operaciones aritméticas habituales se aplican elemento a elemento. Si las dimensiones de las matrices son distintas se produce un error.\n\n:::{#exm-operaciones-aritmeticas-matrices}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-43_b1b3581fa4f92ea2f8eef0958f05d20d'}\n\n```{.r .cell-code}\nx <- matrix(1:6, nrow = 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\ny <- matrix(c(0, 1, 0, -1, 0, 1), nrow = 2)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    1   -1    1\n```\n:::\n\n```{.r .cell-code}\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    3    3    7\n```\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    2   -4    6\n```\n:::\n\n```{.r .cell-code}\nx / y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]  Inf  Inf  Inf\n[2,]    2   -4    6\n```\n:::\n\n```{.r .cell-code}\nx ^ y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1 1.00    1\n[2,]    2 0.25    6\n```\n:::\n:::\n\n:::\n\n:::{.callout-warning}\nObsérvese en el ejemplo anterior que la división por 0 produce el valor `Inf` que representa infinito.\n:::\n\n### Multiplicación de matrices \n\nPara multiplicar dos matrices numéricas se utiliza el operador `%*%`.\n\n:::{#exm-producto-matrices}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-44_beda1ad561fd6c137a256ca0044af241'}\n\n```{.r .cell-code}\nx <- matrix(1:6, ncol = 3)\ny <- matrix(1:6, nrow = 3)\nx %*% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   22   49\n[2,]   28   64\n```\n:::\n\n```{.r .cell-code}\ny %*% x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    9   19   29\n[2,]   12   26   40\n[3,]   15   33   51\n```\n:::\n:::\n\n:::\n\n:::{.callout-warning}\nPara poder multiplicar dos matrices deben tener dimensiones compatibles. Si el número de columnas de la primera matriz no es igual que el número de filas de la segunda se produce un error.\n:::\n\n### Determinante de una matriz\n\n- `det(x)`: Devuelve el determinante de la matriz `x`. Si `x` no es una matriz numérica cuadrada produce un error.\n\n:::{#exm-determinante}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-45_f7f984f2f659d5a845ba0d843f1ccaa3'}\n\n```{.r .cell-code}\nx <- matrix(1:4, ncol = 2)\ndet(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2\n```\n:::\n:::\n\n:::\n\n### Inversa de una matriz\n\n- `solve(x)`: Devuelve la matriz inversa de la matriz `x`. Si `x` no es una matriz numérica cuadrada produce un error. Si la matriz no es invertible por tener determinante nulo también se obtiene un error.\n\n:::{#exm-inversa-matriz}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-46_01d7ccc45a61d2c995a998dbda453639'}\n\n```{.r .cell-code}\nx <- matrix(1:4, nrow = 2)\nsolve(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n```\n:::\n\n```{.r .cell-code}\n# El producto de una matriz por su inversa es la matriz identidad.\nx %*% solve(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n:::\n:::\n\n:::\n\n### Autovalores y autovectores de una matriz\n\n- `eigen(x)`: Devuelve una lista con los autovalores y los autovectores de la matriz `x`. Para acceder a los autovalores se utiliza el nombre `values` y para acceder a los autovectores se utiliza el nombre `vectors`. Si `x` no es una matriz numérica cuadrada produce un error.\n\n:::{#exm-autovalores-autovectores}\n\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-47_5ec4c342370f77461df28d19e796efb9'}\n\n```{.r .cell-code}\nx <- matrix(1:4, nrow = 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\n# Autovalores\neigen(x)$values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5.3722813 -0.3722813\n```\n:::\n\n```{.r .cell-code}\n# Autovectores\neigen(x)$vectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]       [,2]\n[1,] -0.5657675 -0.9093767\n[2,] -0.8245648  0.4159736\n```\n:::\n:::\n\n:::\n\n## Data frames\n\nUn _data frame_ es una estructura bidimensional cuyos elementos se organizan por filas y columnas de manera similar a una matriz. La principal diferencia con las matrices es que sus columnas están formadas por vectores, pero pueden tener tipos de datos distintos. \n\nUn data frame es un caso particular de lista formada por vectores del mismo tamaño con nombre. \n\nLos data frames son las estructuras de datos más utilizadas en R para almacenar los datos en los análisis estadísticos.\n\n### Creación de un data frame\n\n- `data.frame(nombrex = x, nombrey = y, ...)`: Devuelve el data frame con columnas los vectores `x`, `y`, etc. y nombres de columna `nombrex`, `nombrey`, etc.\n\n:::{#exm-creacion-data-frames}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-48_43a303dc1bf419c237b8a2697442bc6e'}\n\n```{.r .cell-code}\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n```\n:::\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t3 obs. of  2 variables:\n $ asignatura: chr  \"Matemáticas\" \"Física\" \"Economía\"\n $ nota      : num  8.5 7 4.5\n```\n:::\n\n```{.r .cell-code}\n# Data frame vacío\ndata.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata frame with 0 columns and 0 rows\n```\n:::\n:::\n\n:::\n\n---\n\nPara grandes conjuntos de datos es más común crear un data frame a partir de un [fichero en formato csv](https://es.wikipedia.org/wiki/Valores_separados_por_comas) mediante la siguiente función:\n\n- `read.csv(f)`: Devuelve el data frame que se genera a partir de los datos del fichero csv `f`. Cada fila del fichero csv se corresponde con una fila del data frame y por defecto utiliza la coma `,` parara separar los datos de las columnas y punto `.` como separador de decimales de los datos numéricos. Los nombres de las columnas se obtienen automáticamente a partir de la primera fila del fichero.\n- `read.csv2(f)`: Funciona igual que la función anterior pero utiliza como separador de columnas el punto y coma `;` y como separador de decimales la coma `,`.\n\n---\n\n:::{#exm-creacion-data-frame-csv}\nA continuación se muestra un ejemplo de creación de un data frame a partir de un fichero csv.\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-49_d7f06658c545e8e6f4ab90a617ea224b'}\n\n```{.r .cell-code}\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2                   Rosa Díaz Díaz   32    M   65   1.73        232\n3            Javier García Sánchez   24    H   NA   1.81        191\n4              Carmen López Pinzón   35    M   65   1.70        200\n5             Marisa López Collado   46    M   51   1.58        148\n6                Antonio Ruiz Cruz   68    H   66   1.74        249\n7          Antonio Fernández Ocaña   51    H   62   1.72        276\n8            Pilar Martín González   22    M   60   1.66         NA\n9             Pedro Gálvez Tenorio   35    H   90   1.94        241\n10         Santiago Reillo Manzano   46    H   75   1.85        280\n11           Macarena Álvarez Luna   53    M   55   1.62        262\n12      José María de la Guía Sanz   58    H   78   1.87        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n14           Carolina Rubio Moreno   20    M   61   1.77        194\n```\n:::\n:::\n\n:::\n\n### Coerción de otras estructuras de datos a data frames\n\nPara convertir otras estructuras de datos en data frames, se utiliza la siguiente función:\n\n- `as.data.frame(x)`: Devuelve el data frame que se obtiene a partir la estructura de datos `x` a plicanco las siguientes reglas de coerción:\n  - Si `x` es un vector se obtiene un data frame con una sola columna.\n  - Si `x` es una lista se obtiene un data frame con tantas columnas como elementos tenga la lista. Si los elementos de la lista tienen tamaños distintos se obtiene un error. \n  - Si `x` es una matriz se obtiene un data frame con el mismo número de columnas y filas que la matriz.\n\n### Acceso a los elementos de un data frame\n\nPuesto que un data frame es una lista, se puede acceder a sus elementos como se accede a los elementos de una lista utilizando índices. Con corchetes simples `[ ]` se obtiene siempre un data frame, mientras que con corchetes dobles `[[ ]]` o `$` se obtiene un vector. \n\nPero también se puede acceder a los elementos de un data frame como si fuese una matriz, indicando un par de índices para las filas y las columnas respectivamente.\n\n---\n\n:::{#exm-acceso-data-frame}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-50_4ddf486592fdcf57981660658af16b09'}\n\n```{.r .cell-code}\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n```\n:::\n\n```{.r .cell-code}\n# Acceso como lista\ndf[\"asignatura\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura\n1 Matemáticas\n2      Física\n3    Economía\n```\n:::\n\n```{.r .cell-code}\ndf$asignatura\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Matemáticas\" \"Física\"      \"Economía\"   \n```\n:::\n\n```{.r .cell-code}\n# Acceso como matriz\ndf[2:3, \"nota\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.0 4.5\n```\n:::\n\n```{.r .cell-code}\ndf[df$nota >= 5, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n```\n:::\n:::\n\n:::\n\nObsérvese en el último ejemplo anterior cómo se pueden utilizar condiciones lógicas para filtrar un data frame.\n\n---\n\nPara acceder a las primeras o últimas filas de un data frame se pueden utilizar las siguientes funciones: \n\n- `head(df, n)`: Devuelve un data frame con las `n` primeras filas del data frame `df`.\n\n- `tail(df, n)`: Devuelve un data frame con las `n` últimas filas del data frame `df`.\n\n:::{#exm-acceso-primeras-ultimas-filas-data-frame}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-51_186182b97967fab4e4dd8f4dcc152b86'}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:26, y = letters) # letters es un vector predefinido con las letras del abecedario.\nhead(df, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 a\n2 2 b\n3 3 c\n```\n:::\n\n```{.r .cell-code}\ntail(df, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    x y\n25 25 y\n26 26 z\n```\n:::\n:::\n\n:::\n\n### Modificación de los elementos de un data frame\n\nPara modificar uno o varios elementos de un data frame basta con acceder a esos elementos y usar el operador de asignación para asignar nuevos valores.\n\n:::{#exm-modificacion-data-frames}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-52_ec43bb624b531ed4fdcfc13040172982'}\n\n```{.r .cell-code}\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"),\n    nota = c(8.5, 7, 4.5))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n```\n:::\n\n```{.r .cell-code}\ndf[3, \"nota\"] <- 5\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  5.0\n```\n:::\n:::\n\n:::\n\n### Añadir elementos a un data frame\n\nPara añadir nuevas filas o columnas a una data frame se utilizan las mismas funciones que para matrices:\n\n- `rbind(df, x)`: Devuelve el data frame que resulta de añadir nuevas filas al data frame `df` con los elementos de la lista `x`.\n\n- `cbind(df, nombrex = x)`: Devuelve el data frame que resulta de añadir nuevas columnas al data frame `df` con los elementos del vector `x` con nombre `nombrex`.\n\n---\n\n:::{#exm-añadir-filas-columnas-data-frame}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-53_67c6bc4625a660453f9db4561c27e74d'}\n\n```{.r .cell-code}\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n```\n:::\n\n```{.r .cell-code}\n# Añadir una nueva fila\nrbind(df, list(\"Programación\" , 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    asignatura nota\n1  Matemáticas  8.5\n2       Física  7.0\n3     Economía  4.5\n4 Programación 10.0\n```\n:::\n\n```{.r .cell-code}\n# Añadir una nueva columna\ncbind(df, créditos = c(6, 4, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura nota créditos\n1 Matemáticas  8.5        6\n2      Física  7.0        4\n3    Economía  4.5        3\n```\n:::\n:::\n\n:::\n\n### Eliminar filas y columnas de un data frame{.scrollable}\n\nPara eliminar una columna de un data frame basta con acceder a la columna y asignarle el valor `NULL`, mientras que para eliminar una fila basta con acceder a la fila con índice negativo. \n\n:::{#exm-eliminacion-filas-columnas-data-frame}\n\n::: {.cell hash='03-tipos-datos-estructurados_cache/revealjs/unnamed-chunk-54_e1e3cac76c4f67ddef69d3a111c691a9'}\n\n```{.r .cell-code}\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5), créditos = c(6, 4, 3))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura nota créditos\n1 Matemáticas  8.5        6\n2      Física  7.0        4\n3    Economía  4.5        3\n```\n:::\n\n```{.r .cell-code}\n# Eliminar una columna\ndf$nota <- NULL\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura créditos\n1 Matemáticas        6\n2      Física        4\n3    Economía        3\n```\n:::\n\n```{.r .cell-code}\n# Eliminar una fila\ndf[-2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   asignatura créditos\n1 Matemáticas        6\n3    Economía        3\n```\n:::\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}